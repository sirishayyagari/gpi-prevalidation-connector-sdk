/*
 * Beneficiary account pre-validation
 * Move your app forward with the Account Pre-Validation API
 *
 * OpenAPI spec version: 1.0.7-oas3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.swift.gpi.preval.api;


import com.swift.gpi.preval.ApiException;
import com.swift.gpi.preval.model.AccountVerificationRequest;
import com.swift.gpi.preval.model.AccountVerificationResponse1;
import com.swift.gpi.preval.model.ErrorCodeConsumer;
import org.everit.json.schema.ValidationException;
import org.junit.Test;
import org.junit.Ignore;
import org.json.*;
import java.io.File;
import java.io.FileWriter;
import org.everit.json.schema.Schema;
import org.everit.json.schema.loader.SchemaLoader;
import javax.xml.*;
import org.everit.*;
import java.util.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.threeten.bp.ZoneOffset;
import org.threeten.bp.ZonedDateTime;

import org.json.JSONObject;
import org.json.JSONTokener;
import org.junit.Test;
import java.io.IOException;


import javax.crypto.Mac;

import javax.crypto.spec.SecretKeySpec;

import javax.xml.bind.DatatypeConverter;



import java.io.UnsupportedEncodingException;

import java.nio.charset.Charset;

import java.security.InvalidKeyException;

import java.security.NoSuchAlgorithmException;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

/**
 * API tests for VerifyAccountApi
 */
@Ignore
public class VerifyAccountApiTest {

     public static String CRLF = "\r\n";

     public static String LAU_VERSION = "1.0";

     public static String APPL_ID = "BO2";

     public static String SIGNED = "(ApplAPIKey=yVGhKiV5z1ZGdaqFXoZ8AiSA9n5CrY6B),(RBACRole=[FullViewer/Scope/GPAGCH3A])";

     public static String LAUKEY = "Abcd1234Abcd1234Abcd1234Abcd1234";

     public static String ABSPATH = "/swift-preval-pilot/v1/accounts/verification";
     

    /**
     * Verify that a beneficiary account could be able to receive incoming funds.
     *
     * The service verifies that an account exists at the beneficiary bank and is capable of receiving incoming funds. This usually implies that the account is open, properly identified by the given number and, depending on the  jurisdiction and the market practices in use where the account is held, that the creditor name matches the name of the account holder. The service provider does not take liability for the response and does not provide any guarantee on the outcome of an actual transaction being sent to this account. The information provided is meant to be as accurate as possible at the time that the request was processed.  The requester must pass the creditor name and the service provider can use this information as part of the verification or not.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void verifyAccountTest() throws ApiException, ValidationException, IOException {

        String jsonStr1 = "{\"correlation_identifier\":\"SCENARIO1-CORRID-001\",\"context\":\"BENR\",\"uetr\":\"b916a97d-a699-4f20-b8c2-2b07e2684a27\",\"creditor_account\":\"GB3112000000001987426375\",\"creditor_name\":\"John Doe\",\"creditor_address\":{\"country\": \"GB\"},\"creditor_organisation_identification\":{\"any_bic\":\"BIC1GB51\"}}";
       // String filePath = new File("/SWIFT-API-gpi-prevalidation-account-verification-request-1.0.7.json").getAbsolutePath();

        JSONObject jsonSchema = new JSONObject(
                new JSONTokener(VerifyAccountApiTest.class.getResourceAsStream("/SWIFT-API-gpi-prevalidation-account-verification-request-1.0.7.json")));

        JSONObject jsonSubject = new JSONObject(
              new JSONTokener(VerifyAccountApiTest.class.getResourceAsStream("/request.json")));

        Schema schema = SchemaLoader.load(jsonSchema);
        schema.validate(jsonSubject);

        Gson g = new Gson();
        AccountVerificationRequest body = null;
        body = g.fromJson(jsonStr1, AccountVerificationRequest.class);
        String jsonStr = g.toJson(body);
        System.out.println(jsonStr);
        String laUApplicationID = "001";
        String laUVersion = "1.0";
        String laUCallTime = getDateTimeInZulu();
        String laURequestNonce = UUID.randomUUID().toString();
        String laUSigned = "(ApplAPIKey=yVGhKiV5z1ZGdaqFXoZ8AiSA9n5CrY6B),(RBACRole=[Update/Scope/BANABEBB],(x-bic=CCLABEB0))";
        // String laUSignature = "JSG3wWUvH51blAmhkkzidw==";
        String xBic = "CCLABEB0";
        String subjectDN = "o=cclausb0,o=swift" ;
        String institution = "CCLABEB0";

        String laUSignature = calculateLAU(laUApplicationID, laUCallTime,laURequestNonce,laUSigned, LAUKEY, ABSPATH, jsonStr);
        System.out.print("\n ABSPATH: "+ABSPATH);
        System.out.print("\n laUApplicationID: "+laUApplicationID);
        System.out.print("\n laUCallTime: "+laUCallTime);
        System.out.print("\n laURequestNonce:"+laURequestNonce);
        System.out.print("\n laUSigned:"+laUSigned);
        System.out.print("\n LAUKEY:"+LAUKEY);
        System.out.print("\n jsonStr:"+jsonStr);
        System.out.print("\n laUSignature:"+laUSignature+"\n");
        System.out.print("\n body:"+body+"\n");

        final VerifyAccountApi api = new VerifyAccountApi();


        AccountVerificationResponse1 response = api.verifyAccount(body, laUApplicationID, laUVersion, laUCallTime, laURequestNonce, laUSigned, laUSignature, xBic, subjectDN, institution);
        Gson gsonObj = new GsonBuilder().setPrettyPrinting().create();
        // converts object to json string
        String json = gsonObj.toJson(response);


        try (FileWriter file = new FileWriter("src/test/resources/response.json")) {
            file.write(json.toString());
            System.out.println("Successfully Copied JSON Object to File...");
            System.out.println("\nJSON Object: " + json);
            JSONObject responseSchemaFile = new JSONObject(
                    new JSONTokener(VerifyAccountApiTest.class.getResourceAsStream("/SWIFT-API-gpi-prevalidation-account-verification-response-1.0.7.json")));

            //JSONObject responsePayload = new JSONObject(
            //        new JSONTokener(VerifyAccountApiTest.class.getResourceAsStream("/response.json")));

            Schema responseSchema = SchemaLoader.load(responseSchemaFile);

            try{
                responseSchema.validate(new JSONObject(json));
                System.out.println("Response payload validated against schema successfully!");
            } catch (ValidationException e){
                e.printStackTrace();
            }

        }

        //System.out.print("\n"+response);
    }
    public static String getDateTimeInZulu(){
       return ZonedDateTime.now(ZoneOffset.UTC).toString();
   }

   public static String calculateLAU(String LAUApplicationID,
                                     String LAUCallTime, String LAURequestNonce, String LAUSigned,
                                     String LAUKey, String absPath, String requestBody)
   {
       try
       {
           Mac mac = Mac.getInstance("HmacSHA256");
           SecretKeySpec keyspec = new SecretKeySpec(
                   LAUKey.getBytes(Charset.forName("US-ASCII")), "HmacSHA256");
           mac.init(keyspec);
           StringBuilder sb = new StringBuilder(2048);
           sb.append("LAUApplicationID:").append(LAUApplicationID.trim()).append(CRLF);
           sb.append("LAUCallTime:").append(LAUCallTime.trim()).append(CRLF);
           sb.append("LAURequestNonce:").append(LAURequestNonce.trim()).append(CRLF);
           sb.append("LAUSigned:").append(LAUSigned.trim()).append(CRLF);
           sb.append("LAUVersion:").append(LAU_VERSION.trim()).append(CRLF);
           sb.append(absPath.trim()).append(CRLF);
           sb.append(requestBody);
           byte[] lau = mac.doFinal(sb.toString().getBytes("UTF-8"));
           byte[] lau_to_encode = new byte[16];
           System.arraycopy(lau, 0, lau_to_encode, 0, 16);
           String LAU = DatatypeConverter.printBase64Binary(lau_to_encode);
           // String LAU = DatatypeConverter.printBase64Binary(lau);
           return LAU;
       }
       catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException ex)
       {
           ex.printStackTrace();
           System.out.println(ex.getMessage());
       }
       return "";
   }

    public void givenInvalidInput_whenValidating_thenInvalid() throws ValidationException {

    }
}
